# 実験02: 対話的タスクにおけるサブエージェントの挙動検証 - 分析結果

## 実験日

2025-11-23

## 実験概要

TODOアプリの「優先度自動調整機能」の要件定義を、2つのパターンで実施し比較した。

**タスク内容:**
- 機能の目的確認
- 自動調整の基準設定
- 調整タイミングの決定
- ユーザー制御の仕様化
- 完成後の修正（「手動調整機能も残したい」）

**実験環境:**
- Claude Code バージョン: （記録済み）
- Claude モデル: Claude Sonnet 4.5

## 比較結果

### 1. 対話フローの効率性

| 項目 | パターンA（サブエージェント） | パターンB（スキル） |
|------|----------------------------|----------------------|
| 対話の自然さ | △ メイン経由で仲介 | ◎ 完全に自然な対話 |
| 質問→回答の流れ | メイン → サブ → メイン → ユーザー | 直接的な会話 |
| セッション継続性 | × 各Task呼び出しで独立 | ◎ 会話全体で継続 |
| やり取り回数 | 4回のTask呼び出し | 1つの継続的な会話 |

**重要な発見:**
- サブエージェントは各Task呼び出しごとに**自動的に終了**
- セッションは保持されず、毎回独立したコンテキスト
- Claude Codeの公式回答で確認済み

**実際の動作:**
パターンA:
1回目: 初回質問提示 → 終了
2回目: 詳細確認質問 → 終了
3回目: 要件定義書作成 → 終了
4回目: 手動機能追加で更新 → 終了
パターンB:
1つの継続した会話内で完結

### 2. コンテキスト分断の影響

| 項目 | パターンA | パターンB |
|------|-----------|-----------|
| セッション分断 | ◯ 実際に発生 | × 発生しない |
| 状態保持の方法 | ファイルベース | 会話コンテキスト |
| 判断理由の保持 | △ ファイルに記載された内容のみ | ◎ 会話履歴全体 |
| 暗黙知の保持 | × 失われる | ◎ 保持される |

**状態保持の仕組み:**

**パターンA（サブエージェント）:**
```
サブエージェント（4回目起動）
↓
既存ファイルを読み込み
(output/priority-auto-adjustment-requirements.md)
↓
内容を理解
↓
修正を反映
↓
ファイルに書き戻し
```

- ✅ ファイルに記録されていれば修正可能
- ❌ 対話中のニュアンスや判断過程は失われる
- ❌ 「なぜその要件にしたか」という暗黙知は保持されない

**パターンB（スキル）:**
```
メインの会話コンテキスト内で完結
↓
すべての対話履歴を保持
↓
判断過程も暗黙知も維持
```

### 3. 修正時の柔軟性

| 項目 | パターンA | パターンB |
|------|-----------|-----------|
| 修正時の確認 | 即座に修正 | 追加の詳細確認 |
| 追加質問 | なし | 3つの確認質問 |
| ユーザーニーズの把握 | ファイル情報のみ | 会話全体から理解 |
| 修正の精度 | 網羅的だが過剰 | 必要十分 |

**修正時の挙動の違い:**

**パターンA:**
```
「手動機能を残したい」
↓
即座に詳細を追加
├─ UI機能3種
├─ リセット機能
├─ 変更履歴
└─ 一括リセット
```
→ 関連する可能性のあることを全部含める（網羅的）

**パターンB:**
```
「手動機能を残したい」
↓
追加の確認質問3つ
├─ 自動復帰は必要？
├─ 調整範囲は？
└─ ハイブリッドは必要？
↓
回答に基づいて必要な分だけ追加
```
→ 確認してから必要な分だけ（適切）

### 4. 成果物の品質

| 項目 | パターンA | パターンB |
|------|-----------|-----------|
| 文書量 | 260行 | 185行 |
| 詳細度 | 非常に詳細 | 必要十分 |
| 優先度レベル | 4段階（表付き） | 3段階 |
| 具体的な数値 | あり（24時間、100ms等） | 抽象的 |
| 利用シナリオ | 6つの詳細例 | なし |
| 用語定義 | あり | なし |
| 実装計画 | 3フェーズ詳細 | 優先順位のみ |

**成果物の性質:**

**パターンA:**
- 実装者向けの詳細仕様書
- 具体的な数値・基準が豊富
- 用途：開発チームが即座に実装できる

**パターンB:**
- ビジネス向けの形式的な要件定義書
- 承認・合意形成に適した構成
- 用途：ステークホルダーとの合意形成

### 5. コンテキスト消費

**測定結果（実験終了時）:**
```
パターンA（サブエージェント）：
Free space: 53.8k (26.9%)
パターンB（メイン+スキル）：
Free space: 53.3k (26.6%)
差分: 0.5k (0.3%)
```

**重要な発見:**
- コンテキスト節約効果は**ほぼゼロ**（0.3%差）
- 対話的タスクではメイン経由になるため節約されない
- サブエージェントの「独立コンテキスト」のメリットが活かせない

## 設計思想の違い

### サブエージェントの設計思想
**「独立したエキスパートとして完璧な成果物を一度で」**

メリット:
- 網羅的で詳細
- 実装に必要な情報が揃っている
- 一度で完結する

デメリット:
- 過剰な情報が含まれる可能性
- ユーザーが本当に必要としていない詳細も含む
- 冗長になりがち
- セッション分断により暗黙知が失われる

**なぜ網羅的になるのか:**
- 独立性ゆえにメインとの往復を最小限にしたい
- 一度で完結させようとする
- 不足があっても後から聞けない（セッション独立）

### スキルの設計思想
**「対話のパートナーとして必要十分を柔軟に」**

メリット:
- 簡潔で読みやすい
- 本当に必要な情報に絞られる
- 追加・修正が容易
- 会話全体の文脈を保持

デメリット:
- 詳細度が不足する可能性
- 追加の質問が必要になる
- 何度かのやり取りが必要

**なぜ柔軟なのか:**
- メインとの継続性があり、いつでも追加確認可能
- 不足があればまた聞けばいい
- 段階的に詳細化できる

## 結論

### 対話的タスク（要件定義）におけるサブエージェントの適性

**❌ サブエージェントは対話的タスクに不向き**

理由：
1. **セッション分断によるコンテキスト喪失**
   - 各Task呼び出しで独立
   - 判断過程や暗黙知が失われる
   - ファイルに書かれていない情報は保持されない

2. **対話の非効率性**
   - メインが仲介役になる
   - 自然な会話フローが阻害される
   - 継続的な対話ができない

3. **コンテキスト節約効果がない**
   - 対話的タスクではメイン経由になる
   - 結果的に同じ情報量を扱う
   - 独立コンテキストのメリットが活かせない

4. **過剰品質の傾向**
   - 一度で完結させようとして網羅的になる
   - ユーザーが必要としていない詳細も含まれる
   - 効率的ではない

### スキルが適している理由

**◎ スキルは対話的タスクに最適**

理由：
1. **継続的な対話が可能**
   - 会話全体が1つのコンテキスト
   - 自然な会話フロー
   - 判断過程・暗黙知がすべて保持される

2. **柔軟な詳細化**
   - 追加確認が容易
   - ユーザーの真のニーズを引き出せる
   - 段階的に合意形成できる

3. **適切な品質**
   - 必要十分な情報に絞られる
   - 過剰な詳細を避けられる
   - 効率的

4. **修正が容易**
   - 会話の文脈を維持したまま修正
   - スムーズな変更対応
   - 追加要件の取り込みが自然

## サブエージェントが有効なケース

今回の実験から、サブエージェントが有効なのは：

### ✅ 適しているタスク

**探索的・試行錯誤型タスク:**
```
例: コード実装
メイン → サブエージェント
↓
[サブエージェント内で大量消費]
├─ 既存コード探索（500トークン）
├─ 複数実装案検討（800トークン）
├─ 試行錯誤（1000トークン）
└─ テスト実行（300トークン）
= 2600トークン消費
↓
メイン ← 結果のみ（50トークン）
```
**メインのコンテキスト: 50トークンのみ増加**

**特徴:**
- 探索的作業が多い
- トライ＆エラーが多い
- 最終結果だけ知れればいい
- ユーザーの意思決定が不要
- 単線的な処理フロー

### ❌ 適していないタスク

**対話的・合意形成型タスク:**
```
例: 要件定義（今回の実験）
メイン → サブエージェント
↓
[対話のやり取り]
├─ メイン経由での質問（100トークン）
├─ メイン経由での回答（100トークン）
├─ メイン経由での質問（100トークン）
├─ メイン経由での回答（100トークン）
└─ 要件定義書作成（200トークン）
= 600トークン
↓
メイン ← 仲介した分も含めて消費
```
**メインのコンテキスト: ≈ 600トークン増加**

**特徴:**
- 対話が本質
- ユーザーの意思決定が必要
- 段階的な合意形成が必要
- 途中経過の透明性が重要
- 判断過程の共有が重要

## 推奨事項

### 1. 要件定義・仕様書作成

**推奨: spec-assistantスキル**

理由:
- 対話的に詳細化できる
- ユーザーの意思決定を尊重
- 段階的な合意形成が可能
- 修正が容易

### 2. 設計・タスク分解

**推奨: design-subagent（サブエージェント）**

理由:
- 確定した仕様書から導出可能
- 探索的作業が多い
- 途中経過より成果物が重要
- コンテキスト節約効果あり

### 3. 実装

**推奨: code-implementer（サブエージェント）**

理由:
- 設計書から導出可能
- 試行錯誤が多い
- 動くコードがあればよい
- コンテキスト節約効果大

### 4. 一般原則

**対話的タスクかどうかで判断:**
```
対話が必要？
├─ YES → メイン + スキル
└─ NO  → サブエージェント検討
    ↓
    探索的作業？
    ├─ YES → サブエージェント
    └─ NO  → メインで十分
```

## 今後の検討事項

1. **サブエージェントの改善可能性**
   - セッション継続機能の追加
   - 会話履歴の自動保存・復元

2. **ハイブリッドアプローチ**
   - メインで要件定義
   - サブエージェントで実装
   - 両者の利点を組み合わせる

3. **他のタスクでの検証**
   - コードレビュー
   - デバッグ
   - リファクタリング

## 参考資料

- パターンA会話ログ: pattern-a-subagent/conversation-log.md
- パターンB会話ログ: pattern-b-skill/conversation-log.md
- パターンA成果物: pattern-a-subagent/output/
- パターンB成果物: pattern-b-skill/output/

---

**最終更新**: 2025年11月24日 05:36:46 JST
**実験者**: trust.delta
